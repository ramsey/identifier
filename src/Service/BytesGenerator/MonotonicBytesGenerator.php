<?php

/**
 * This file is part of ramsey/identifier
 *
 * ramsey/identifier is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * ramsey/identifier is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with ramsey/identifier. If not, see
 * <https://www.gnu.org/licenses/>.
 *
 * @copyright Copyright (c) Ben Ramsey <ben@ramsey.dev> and Contributors
 * @license https://opensource.org/license/lgpl-3-0/ GNU Lesser General Public License version 3 or later
 */

declare(strict_types=1);

namespace Ramsey\Identifier\Service\BytesGenerator;

use DateTimeInterface;
use Psr\Clock\ClockInterface as Clock;
use Ramsey\Identifier\Service\Clock\SystemClock;

use function assert;
use function hash;
use function pack;
use function random_bytes;
use function substr;
use function unpack;

/**
 * A generator that ensures the bytes generated are always greater than the value of the previous bytes generated.
 *
 * Code and concepts within this class are borrowed from the symfony/uid package and are used under the terms of the MIT
 * license distributed with symfony/uid.
 *
 * symfony/uid is copyright (c) Fabien Potencier.
 *
 * @link https://symfony.com/components/Uid Symfony Uid component.
 * @link https://github.com/symfony/uid/blob/v7.2.0/UuidV7.php Symfony UuidV7 class.
 * @link https://github.com/symfony/uid/blob/7.2/LICENSE MIT License.
 */
final class MonotonicBytesGenerator implements BytesGenerator
{
    private static ?int $time = null;
    private static ?string $seed = null;
    private static int $seedIndex = 0;

    /**
     * An array of 16-bit integers unpacked from randomly generated bytes.
     *
     * @var int[]
     */
    private static array $rand = [];

    /**
     * A pre-generated pool of random integers to use when increasing the value.
     *
     * @var int[]
     */
    private static array $seedParts;

    public function __construct(
        private readonly BytesGenerator $bytesGenerator = new RandomBytesGenerator(),
        private readonly Clock $clock = new SystemClock(),
    ) {
    }

    public function bytes(int $length = 16, ?DateTimeInterface $dateTime = null): string
    {
        $argDateTime = $dateTime;
        $dateTime = $argDateTime ?? $this->clock->now();

        $time = (int) $dateTime->format('Uv');

        // If we're within the same millisecond as the last time, let's increment(). Otherwise, we'll randomize().
        if (self::$time === null || $time > self::$time || ($argDateTime !== null && $time !== self::$time)) {
            $this->randomize($time);
        } else {
            $time = $this->increment();
        }

        $bytes = substr(pack('J', $time), -6)
            . pack('n*', self::$rand[1], self::$rand[2], self::$rand[3], self::$rand[4], self::$rand[5]);

        /** @var non-empty-string */
        return match (true) {
            $length > 16 => $bytes . random_bytes($length - 16),
            $length < 16 => substr($bytes, 0, $length),
            default => $bytes,
        };
    }

    private function randomize(int $time): void
    {
        if (self::$seed === null) {
            $seed = $this->bytesGenerator->bytes(16);
            self::$seed = $seed;
        } else {
            $seed = $this->bytesGenerator->bytes(10);
        }

        /** @var int[] $rand */
        $rand = unpack('n*', $seed);

        // Unset the first six bits of the first 16-bit integer. This space is reserved as a buffer for detecting
        // overflows. See where we test `0xfc00 & self::$rand[1]` in the increment() method.
        $rand[1] &= 0x03ff;

        self::$rand = $rand;
        self::$time = $time;
    }

    /**
     * Within the same millisecond, increment the random part by a random 24-bit integer.
     *
     * To illustrate how this works, let's assume we randomly generated bytes in `randomize()` so that we now have an
     * array of five 16-bit integers, and each of them has all 16 bits set (randomly, tooâ€”what are the odds?). In other
     * words, their values are all `0xffff`. In the `randomize()` method, we masked the first value to `0x03ff`, and
     * `0xffff & 0x03ff === 0x03ff`, so `0x03ff` is the value of the first array element.
     *
     * Our `$rand` array looks like this:
     *
     * ```
     * [
     *     1 => 0x03ff,
     *     2 => 0xffff,
     *     3 => 0xffff,
     *     4 => 0xffff,
     *     5 => 0xffff,
     * ]
     * ```
     *
     * > [!NOTE]
     * > When not naming elements with the `unpack()` method in PHP, it will unpack the binary data into a 1-indexed
     * > array, rather than a 0-indexed array. That's why this array starts at `1`.
     *
     * For the sake of simplicity, let's also assume that the seed part (the random 24-bit integer we want to add to
     * increment the random part) for the current seed index is a 24-bit integer with all bits set. So its value is
     * `0xffffff` (how random!).
     *
     * With that established, let's step through this algorithm.
     *
     * 1. In the first step, we take the fifth element of the `$rand` array, which is `0xffff`, add `1` to it (to
     *    prevent collisions within the same millisecond), and add our seed part of `0xffffff`. We also mask this to 24
     *    bits, but that won't change its value unless it's greater than 24 bits; the seed parts array also contains
     *    32-bit integers, so this masking is necessary.
     *
     *    At this point, the fifth element in `$rand` has the value `0x0100ffff`. This is also the current `$carry`
     *    value.
     *
     *    ```
     *    0xffff + 1 + (0xffffff & 0xffffff) === 0x0100ffff
     *    ```
     *
     *    If we look at the bits in `$carry`, we can begin to see what's going on and how this algorithm works. Here's
     *    the current value of `$carry` in bit layout:
     *
     *    ```
     *    1  0000 0000  1111 1111  1111 1111
     *    ```
     *
     *    > [!TIP]
     *    > Watch what happens when we shift this to right by 16 places, in the next step.
     *
     * 2. Now, we take the fourth element of the `$rand` array, which is also `0xffff` and add the value of `$carry`
     *    shifted 16 bits to the right.
     *
     *    When we shift `$carry` to the right by 16 places, we drop the 16 least significant (right-most) bits, leaving
     *    us with `100000000` (or `0x100` or `256`).
     *
     *    ```
     *    0xffff + (0x0100ffff >> 16) === 0x0100ff
     *    ```
     *
     *    The fourth element of `$rand` now has the value `0x0100ff`, as does `$carry`. Here's what this number looks
     *    like in bits:
     *
     *    ```
     *    1  0000 0000  1111 1111
     *    ```
     *
     *    Things are getting interesting!
     *
     * 3. Next, we take the third element of the `$rand` array, which, again, is `0xffff`, and we add the value of
     *    `$carry`, shifted again 16 bits to the right.
     *
     *    When we shift `$carry` 16 bits to the right, we again drop the 16 least significant bits, leaving us with 1
     *    bit, which we add to `0xffff`. This number already has 16 bits set, so now, it has 17 bits set. It has one bit
     *    left over.
     *
     *    ```
     *    0xffff + (0x0100ff >> 16) === 0x010000
     *    ```
     *
     * 4. We do the same again for the fourth element of `$rand`. When we shift `$carry` 16 bits to the right, we're
     *    left with `1`, which we add to the value of `$rand` (`0xffff`), creating another case where we have 17 bits
     *    set. This carries on through to step 5.
     *
     *    ```
     *    0xffff + (0x010000 >> 16) === 0x010000
     *    ```
     *
     * 5. Finally, we shift the value of `$carry` (`0x010000`) 16 bits to the right, giving us `1` (again), and we add
     *    this to the value of the fifth element of `$rand`, which, you'll recall, is `0x03ff` because we masked out its
     *    6 most significant (left-most) bits.
     *
     *    In binary form, this number currently looks like:
     *
     *    ```
     *    0000 0011  1111 1111
     *    ```
     *
     *    But we still have a carry value we need to shift 16 bits to the right and then add to this number. Shifting
     *    `0x010000` 16 bits to the right gives us `1`. When we add that to the fifth value, we get the following bits:
     *
     *    ```
     *    0000 0100  0000 0000
     *    ```
     *
     *    Now, one of the six most significant bits is set, so when we test `0xfc00 & self::$rand[1]`, it results in a
     *    value other than 0, letting us know that it has one or more bits set in the six most significant bits. This
     *    triggers the generator to generate a new random seed value.
     *
     * Each time we do this, we decrement the seed index by 1, and when it reaches 0, we regenerate the seed parts by
     * getting a sha512 hash of the previous seed bytes. In doing this, we can avoid having to regenerate random bytes
     * until we absolutely need to.
     */
    private function increment(): int
    {
        if (self::$seedIndex === 0 && self::$seed !== null) {
            $this->generateSeedParts();
        }

        self::$rand[5] = 0xffff & $carry = self::$rand[5] + 1 + (self::$seedParts[self::$seedIndex--] & 0xffffff);
        self::$rand[4] = 0xffff & $carry = self::$rand[4] + ($carry >> 16);
        self::$rand[3] = 0xffff & $carry = self::$rand[3] + ($carry >> 16);
        self::$rand[2] = 0xffff & $carry = self::$rand[2] + ($carry >> 16);
        self::$rand[1] += $carry >> 16;

        assert(self::$time !== null);

        if (0xfc00 & self::$rand[1]) {
            $this->randomize(self::$time + 1);
        }

        /** @var int */
        return self::$time;
    }

    /**
     * Generate a pool of random integers for increasing the value.
     *
     * Instead of getting these values from `random_bytes()`, which is slow, we get them by sha512-hashing
     * `self::$seed`. This produces 64 bytes of entropy, which we split into a list of 24-bit integers. `unpack()` first
     * splits the bytes into sixteen 32-bit integers. We then take the first byte from each of these integers to get
     * five additional 24-bit integers.
     *
     * We can now use these twenty-one integers as a pool to increment our value.
     */
    private function generateSeedParts(): void
    {
        assert(self::$seed !== null);
        self::$seed = hash('sha512', self::$seed, true);

        /** @var int[] $s */
        $s = unpack('l*', self::$seed);

        $s[] = ($s[1] >> 8 & 0xff0000) | ($s[2] >> 16 & 0xff00) | ($s[3] >> 24 & 0xff);
        $s[] = ($s[4] >> 8 & 0xff0000) | ($s[5] >> 16 & 0xff00) | ($s[6] >> 24 & 0xff);
        $s[] = ($s[7] >> 8 & 0xff0000) | ($s[8] >> 16 & 0xff00) | ($s[9] >> 24 & 0xff);
        $s[] = ($s[10] >> 8 & 0xff0000) | ($s[11] >> 16 & 0xff00) | ($s[12] >> 24 & 0xff);
        $s[] = ($s[13] >> 8 & 0xff0000) | ($s[14] >> 16 & 0xff00) | ($s[15] >> 24 & 0xff);

        self::$seedParts = $s;
        self::$seedIndex = 21;
    }
}
